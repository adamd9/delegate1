%% Mermaid diagram: sessionManager flows (voice, text, SMS, supervisor, shared)
%% Source: websocket-server/src/sessionManager.ts

flowchart TD
  %% Subgraphs by channel
  subgraph Voice[Voice (Twilio ↔ Realtime)]
    V1["handleCallConnection(ws, apiKey)"]
    V2["handleTwilioMessage(data)"]
    V2a["event=start -> tryConnectModel()"]
    V2b["event=media -> input_audio_buffer.append"]
    V2c["event=close -> closeAllConnections()"]
    VM["modelConn (OpenAI Realtime WS)"]
    V3["handleModelMessage(data, logsClients, chatClients)"]
  end

  subgraph Text[Text (Chat WS ↔ Responses API)]
    T1["handleChatConnection(ws, apiKey, chatClients, logsClients)"]
    T2["handleChatMessage(data, chatClients, logsClients)"]
    T2a["type=chat.message -> handleTextChatMessage(content, chatClients, logsClients)"]
    T2b["type=session.update -> session.saved_config = msg.session"]
    TT["handleTextChatMessage(content, chatClients, logsClients)"]
    R1["OpenAI Responses: responses.create(requestBody)"]
    R2["Process response.output: if function_call present"]
    R3["Execute FunctionHandler.handler(args, addBreadcrumb)"]
    R4["Follow-up responses.create(previous_response_id, function_call_output)"]
    T3["conversationHistory.push(assistant) [supervisor=true]"]
    T4["Broadcast to chatClients -> { type: 'chat.response' }"]
  end

  subgraph SMS[SMS (Webhook)]
    S1["server.ts POST /sms"]
    S2["handleTextChatMessage(messageText, chatClients, logsClients)"]
    S3["Optional: sendSms(...) on function call breadcrumbs"]
  end

  %% Shared components
  subgraph Shared[Shared Components]
    H1["conversationHistory[]"]
    H2["getAllFunctions() → FunctionHandler[]"]
    H3["functionSchemas (tools)"]
    H4["logsClients (observability)"]
    H5["chatClients (text clients)"]
    H6["session.openaiClient (REST)"]
    H7["session.modelConn (Realtime WS)"]
    H8["addBreadcrumb(title, data) -> logsClients (+ optional sendSms)"]
  end

  %% Frontend observability
  subgraph Frontend[Frontend Observability (/logs)]
    F1["handleFrontendConnection(ws, logsClients)"]
    F2["handleFrontendMessage(data)"]
    F3["shouldForwardToFrontend(event)"]
  end

  %% Edges - Voice
  V1 -->|"ws.on('message')"| V2
  V2 --> V2a
  V2 --> V2b
  V2 --> V2c
  V2a -->|"connects OpenAI Realtime"| VM
  VM -->|"ws.on('message')"| V3
  V3 -->|"filtered events"| F4[/"logsClients\n(conversation.item.created, etc.)"/]
  V3 -->|"assistant audio/text events"| V2b

  %% Edges - Text
  T1 -->|"ws.on('message')"| T2
  T2 --> T2a
  T2 --> T2b
  T2a --> TT
  TT -->|"ensure"| H6
  TT -->|"user msg -> push"| H1
  TT --> R1
  R1 --> R2
  R2 -->|"if present"| R3
  R3 -->|"result -> follow-up"| R4
  R4 --> T3
  T3 --> T4
  TT -->|"observability"| H4

  %% Edges - SMS
  S1 --> S2
  S2 -->|"same path as Text"| R1
  R2 -->|"SMS breadcrumb hook"| S3

  %% Shared edges
  TT -->|"tools listing"| H3
  H3 -->|"derived from"| H2
  R3 -->|"use handler(args, addBreadcrumb)"| H2
  H8 --> H4
  H8 -->|"optional (if isSmsWindowOpen())"| S3

  %% Frontend observability edges
  F1 -->|"replay history"| H1
  F1 -->|"ws.on('message')"| F2
  F2 -->|"pass to modelConn for voice session.update"| H7
  V3 -->|"uses filter"| F3

  %% Styling
  classDef shared fill:#E8F5E9,stroke:#2E7D32,stroke-width:1px,color:#1B5E20;
  classDef voice fill:#E3F2FD,stroke:#1565C0,stroke-width:1px,color:#0D47A1;
  classDef text fill:#FFF3E0,stroke:#EF6C00,stroke-width:1px,color:#E65100;
  classDef sms fill:#FCE4EC,stroke:#AD1457,stroke-width:1px,color:#880E4F;
  classDef frontend fill:#F3E5F5,stroke:#6A1B9A,stroke-width:1px,color:#4A148C;

  class Voice, V1,V2,V2a,V2b,V2c,VM,V3 voice
  class Text, T1,T2,T2a,T2b,TT,R1,R2,R3,R4,T3,T4 text
  class SMS, S1,S2,S3 sms
  class Shared, H1,H2,H3,H4,H5,H6,H7,H8 shared
  class Frontend, F1,F2,F3 frontend
